---
author: DBlogAdmin
comments: false
date: 2017-11-03 13:39:20+00:00
excerpt: The D Language Foundation is happy to announce DMD 2.077.0. This latest release
  of the reference compiler for the D programming language is available from the dlang.org
  Downloads page. Among the usual slate of bug and regression fixes, this release
  brings a couple of particulary beneficial enhancements that will have an immediate
  impact on some existing projects.
layout: post
link: https://dlang.org/blog/2017/11/03/dmd-2-077-0-released/
slug: dmd-2-077-0-released
title: DMD 2.077.0 Released
wordpress_id: 1219
categories:
- Code
- Compilers &amp; Tools
- Core Team
- DMD Releases
- News
---

![](http://dlang.org/blog/wp-content/uploads/2016/08/d6.png)

The D Language Foundation is happy to announce DMD 2.077.0. This latest release of the reference compiler for the D programming language is available from the [dlang.org Downloads page](https://dlang.org/download.html). Among the usual slate of [bug and regression fixes](https://dlang.org/changelog/2.077.0.html), this release brings a couple of particulary beneficial enhancements that will have an immediate impact on some existing projects.


### Cutting symbol bloat


Thanks to Rainer Schütze, the compiler now produces significantly smaller mangled names in situations where they had begun to get out of control, particularly in the case of IFTI (Implicit Function Template Instantiation) where Voldemort types are involved. That may call for a bit of a detour here.


#### The types that shall not be named


[Voldemort types](https://wiki.dlang.org/Voldemort_types) are perhaps one of D’s more interesting features. They look like this:

```d
auto getHeWhoShallNotBeNamed() 
{
    struct NoName 
    {
        void castSpell() 
        {
            import std.stdio : writeln;
            writeln("Crucio!");
        }           
    }
    return NoName();
}

void main() 
{
    auto voldemort = getHeWhoShallNotBeNamed();
    voldemort.castSpell();
}
```
Here we have an [auto function](https://dlang.org/spec/function.html#auto-functions), a function for which the return type is inferred, returning an instance of a type declared inside the function. It’s possible to access public members on the instance even though its type can never be named outside of the function where it was declared. Coupled with type inference in variable declarations, it’s possible to store the returned instance and reuse it. This serves as an extra level of encapsulation where it’s desired.

In D, for any given API, as far as the world outside of a module is concerned, _module private_ is the lowest level of encapsulation.

```d
module foobar;

private struct Foo
{
    int x;
}

struct Bar 
{
    private int y;
    int z;
}
```
Here, the type `Foo` is module private. `Bar` is shown here for completeness, as those new to D are often surprised to learn that private members of an aggregate type are also module private (D’s equivalent of the C++ `friend` relationship). There is no keyword that indicates a lower level of encapsulation.

Sometimes you just may not want `Foo` to be visible to the entire module. While it’s true that anyone making a breaking change to Foo’s interface also has access to the parts of the module that break (which is the rationale behind module-private members), there are times when you may not want the entire module to have access to `Foo` at all. Voldemort types fill that role of hiding details not just from the world, but from the rest of the module.


#### The evil side of Voldemort types


One unforeseen consequence of Voldemort types that was [first reported](https://issues.dlang.org/show_bug.cgi?id=15831) in mid–2016 was that, when used in templated functions, they caused a serious explosion in the size of the mangled function names (in some cases up to 1 MB!), making for some massive object files. There was a good bit of forum discussion on how to trim them down, with a number of ideas tossed around. Ultimately, Rainer Schütze took it on. His persistence has resulted in shorter mangled names all around, but the wins are particularly impressive when it comes to IFTI and Voldemort types. (Rainer is also the maintainer of [Visual D](http://rainers.github.io/visuald/visuald/StartPage.html), the D programming language plugin for Visual Studio)

D’s name-mangling scheme is detailed in the [ABI documentation](https://dlang.org/spec/abi.html#name_mangling). The description of the new enhancement is in the section titled [‘Back references’](https://dlang.org/spec/abi.html#back_ref).


### Improved vectorization


D has long supported array operations such as element-wise addtion, multiplication, etc. For example:

    int[] arr1 = [0, 1, 2];
    int[] arr2 = [3, 4, 5];
    int[3] arr3 = arr1[] + arr2[];
    assert(arr3 == [3, 5, 7]);
In some cases, such operations could be vectorized. The reason it was _some_ cases and not _all_ cases is because dedicated assembly routines were used to achieve the vectorization and they weren’t implemented for every case.

With 2.077.0, that’s no longer true. Vectorization is now templated so that all array operations benefit. Any codebase out there using array operations that were not previously vectorized can expect a sizable performance increase for those operations thanks to the increased throughput (though whether an application benefits overall is of course context-dependent). How the benefit is received depends on the compiler being used. From the changelog:


For GDC/LDC the implementation relies on auto-vectorization, for DMD the implementation performs the vectorization itself. Support for vector operations with DMD is determined statically (-mcpu=native, -mcpu=avx2) to avoid binary bloat and the small test overhead. DMD enables SSE2 for 64-bit targets by default.


_Note that the changelog initially showed `-march` instead of `-mcpu` in the quoted lines, and the updated version had not yet been posted when this announcement was published._

DMD’s implementation is implemented in terms of [`core.simd`](https://dlang.org/spec/simd.html#core_simd), which is also [part of DRuntime’s public API](https://dlang.org/phobos/core_simd.html).

The changelog also notes that there’s a potential for division performed on float arrays in existing code to see a performance decrease in exchange for an increase in precision.


The implementation no longer weakens floating point divisions (e.g. `ary[] / scalar`) to multiplication (`ary[] * (1.0 / scalar)`) as that may reduce precision. To preserve the higher performance of float multiplication when loss of precision is acceptable, use either `-ffast-math` with GDC/LDC or manually rewrite your code to multiply by (`1.0 / scalar`) for DMD.




### Other assorted treats


Just the other day, someone asked in the forums if DMD supports [reproducible builds](https://reproducible-builds.org/). As of 2.077.0, the answer is affirmative. DMD now ensures that compilation is deterministic such that given the same source code and the same compiler version, the binaries produced will be identical. If this is important to you, be sure not to use any of the non-determistic lexer tokens (`__DATE__`, `__TIME__`, and `__TIMESTAMP__`) in your code.

DMD’s `-betterC` command line option gets some more love in this release. When it's enabled, DRuntime is not available. Library authors can now use the [predefined version](https://dlang.org/spec/version.html#predefined-versions) `D_BetterC` to determine when that is the case so that, where it’s feasible, they can more conveniently support applications with and without the runtime. Also, the option’s behavior [is now documented](https://dlang.org/spec/betterc.html), so it’s no longer necessary to go to the forums or parse through search results to figure out what is and isn’t actually supported in BetterC mode.

The entire changelog is, as always, [available at dlang.org](https://dlang.org/changelog/2.077.0.html).
