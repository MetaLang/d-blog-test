---
author: DBlogAdmin
comments: false
date: 2017-09-01 15:08:09+00:00
excerpt: The core D team is proud to announce that version 2.076.0 of DMD, the reference
  compiler for the D programming language, is ready for download. The two biggest
  highlights in this release are the new static foreach feature for improved generative
  and generic programming, and significantly enhanced C language integration making
  incremental conversion of C projects to D easy and profitable.
layout: post
link: https://dlang.org/blog/2017/09/01/dmd-2-076-0-released/
slug: dmd-2-076-0-released
title: DMD 2.076.0 Released
wordpress_id: 1062
categories:
- Code
- Compilers &amp; Tools
- Core Team
- DMD Releases
- News
---

![](http://dlang.org/blog/wp-content/uploads/2016/08/d6.png)The core D team is proud to announce that version 2.076.0 of DMD, the reference compiler for the D programming language, is [ready for download](https://dlang.org/changelog/2.076.0.html). The two biggest highlights in this release are the new `static foreach` feature for improved generative and generic programming, and significantly enhanced C language integration making incremental conversion of C projects to D easy and profitable.


### static foreach


As part of its support for generic and generative programming, D allows for conditional compilation by way of constructs such as `version` and `static if` statements. These are used to choose different code paths during compilation, or to generate blocks of code in conjunction with string and template mixins. Although these features enable possibilities that continue to be discovered, the lack of a compile-time loop construct has been a steady source of inconvenience.

Consider this example, where a series of constants named `val0` to `valN` needs to be generated based on a number `N+1` specified in a configuration file. A real configuration file would require a function to parse it, but for this example, assume the file `val.cfg` is defined to contain a single numerical value, such as `10`, and nothing else. Further assuming that `val.cfg` is in the same directory as the `valgen.d` source file, use the command line `dmd -J. valgen.d` to compile.

```d
module valgen;
import std.conv : to;

enum valMax = to!uint(import("val.cfg"));

string genVals() 
{
    string ret;
    foreach(i; 0 .. valMax) 
    {
        ret ~= "enum val" ~ to!string(i) ~ "=" ~ to!string(i) ~ ";";
    }
    return ret;
}

string genWrites() 
{
    string ret;
    foreach(i; 0 .. valMax) 
    {
        ret ~= "writeln(val" ~ to!string(i) ~ ");";
    }
    return ret;
}

mixin(genVals);

void main() 
{
    import std.stdio : writeln;
    mixin(genWrites);
}
```
The manifest constant `valMax` is initialized by [the `import` expression](https://dlang.org/spec/expression.html#import_expressions), which reads in a file during compilation and treats it as a string literal. Since we’re dealing only with a single number in the file, we can pass the string directly to the `std.conv.to` function template to convert it to a `uint`. Because `valMax` is an `enum`, the call to `to` must happen during compilation. Finally, because `to` [meets the criteria](https://dlang.org/spec/function.html#interpretation) for compile-time function evaluation (CTFE), the compiler hands it off to the interpreter to do so.

The `genVals` function exists solely to generate the declarations of the constants `val0` to `valN`, where `N` is determined by the value of `valMax`. The string mixin on line 26 forces the call to `genVals` to happen during compilation, which means this function is also evaluated by the compile-time interpreter. The loop inside the function builds up a single string containing the declaration of each constant, then returns it so that it can be mixed in as several constant declarations.

Similarly, the `genWrites` function has the single-minded purpose of generating one `writeln` call for each constant produced by `genVals`. Again, each line of code is built up as a single string, and the string mixin inside the `main` function forces `genWrites` to be executed at compile-time so that its return value can be mixed in and compiled.

Even with such a trivial example, the fact that the generation of the declarations and function calls is tucked away inside two functions is a detriment to readability. Code generation can get quite complex, and any functions created only to be executed during compilation add to that complexity. The need for iteration is not uncommon for anyone working with D’s compile-time constructs, and in turn neither is the implementation of functions that exist just to provide a compile-time loop. The desire to avoid such boilerplate has put the idea of a `static foreach` as a companion to `static if` high on many wish lists.

At [DConf 2017](http://dconf.org/2017/index.html), Timon Gehr rolled up his sleeves during the hackathon and implemented [a pull request](https://github.com/dlang/dmd/pull/6760) to add support for `static foreach` to the compiler. He followed that up with a D Improvement Proposal, [DIP 1010](https://github.com/dlang/DIPs/blob/master/DIPs/DIP1010.md), so that he could make it official, and the DIP met with enthusiastic approval from the language authors. With DMD 2.076, it’s [finally ready](https://dlang.org/changelog/2.076.0.html#staticforeach) for prime time.

With this new feature, the above example can be rewritten as follows:

```d
module valgen2;
import std.conv : to;

enum valMax = to!uint(import("val.cfg"));

static foreach(i; 0 .. valMax) 
{
    mixin("enum val" ~ to!string(i) ~ "=" ~ to!string(i) ~ ";");
}

void main() 
{
    import std.stdio : writeln;
    static foreach(i; 0 .. valMax) 
    {
        mixin("writeln(val" ~ to!string(i) ~ ");");
    }
}
```
Even such a trivial example brings a noticeable improvement in readability. Don’t be surprised to see compile-time heavy D libraries (and aren’t most of them?) get some major updates in the wake of this compiler release.


### Better C integration and interoperation


DMD’s `-betterC` command line switch has been around for quite a while, though it didn’t really do much and it has languished from inattention while more pressing concerns were addressed. With DMD 2.076, its time has come.

The idea behind the feature is to make it even easier to combine both D and C in the same program, with an emphasis on incrementally replacing C code with D code in a working project. D has been compatible with the C ABI from the beginning and, with some work to translate C headers to D modules, can directly make C API calls without going through any sort of middleman. Going the other way and incorporating D into C programs has also been possible, but not as smooth of a process.

Perhaps the biggest issue has been DRuntime. There are certain D language features that depend on its presence, so any D code intended to be used in C needs to bring the runtime along and ensure that it’s initialized. That, or all references to the runtime need to be excised from the D binaries before linking with the C side, something that requires more than a little effort both while writing code and while compiling it.

`-betterC` aims to dramatically reduce the effort required to bring D libraries into the C world and modernize C projects by partially or entirely converting them to D. DMD 2.076 makes significant progress toward that end. When `-betterC` is specified on the command line, all asserts in D modules will now use the C assert handler rather than the D assert handler. And, importantly, neither DRuntime nor Phobos, the D standard library, will be automatically linked in as they normally are. This means it’s no longer necessary to manually configure the build process or fix up the binaries when using `-betterC`. Now, object files and libraries generated from D modules can be directly linked into a C program without any special effort. This is especially easy when using [VisualD](http://rainers.github.io/visuald/visuald/StartPage.html), the D plugin for Visual Studio. Not too long ago, it gained support for mixing C and D modules in the same project. The updated `-betterC` switch makes it an even more convenient feature.

While the feature is now more usable, it’s not yet complete. More work remains to be done in future releases to allow the use of more D features currently prohibited in `betterC`. Read more about the feature in Walter Bright’s article here on the D Blog, [D as a Better C](https://dlang.org/blog/2017/08/23/d-as-a-better-c/).


### A new release schedule


This isn’t a compiler or language feature, but it’s a process feature worth noting. This is the first release conforming to a new release schedule. From here on out, beta releases will be announced on the 15th of every even month, such as 2017–10–15, 2017–12–15, 2018–2–15, etc. All final releases will be scheduled for the 1st of every odd month: 2017–11–01, 2018–01–01, 2018–03–01, etc. This will bring some reliability and predictability to the release schedule, and make it easier to plan milestones for enhancements, changes, and new features.


### Get it now!


As always, the changes, fixes, and enhancements for this release can be found in [the changelog](https://dlang.org/changelog/2.076.0.html). This specific release will always be available for download at [http://downloads.dlang.org/releases/2.x/2.076.0](http://downloads.dlang.org/releases/2.x/2.076.0), and the latest release plus betas and nightlies can be found at the [download page](https://dlang.org/download.html) on the DLang website.
