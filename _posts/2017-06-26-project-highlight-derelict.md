---
author: DBlogAdmin
comments: false
date: 2017-06-26 14:22:57+00:00
layout: post
link: https://dlang.org/blog/2017/06/26/project-highlight-derelict/
slug: project-highlight-derelict
title: 'Project Highlight: Derelict'
wordpress_id: 919
categories:
- Game Development
- Project Highlights
---

Previous [project highlights](https://dlang.org/blog/category/project-highlights/) on this blog were written up both in my own words and in quotes from the project maintainers. This time around is different -- it would be a little odd to quote ![](http://dlang.org/blog/wp-content/uploads/2017/06/derelict-windmill.jpg)myself while writing about my own project.

Derelict is a collection of D bindings to C libraries. In its present incarnation, it resides in a GitHub organization called [DerelictOrg](https://github.com/DerelictOrg). There you'll find bindings to a number of libraries such as [SDL](https://libsdl.org/), [GLFW](http://www.glfw.org/), [SFML](http://sfml-dev.org/), [OpenGL](https://www.opengl.org/), [OpenAL](https://openal.org/), [FreeType](https://www.freetype.org/), [FreeImage ](http://freeimage.sourceforge.net/)and more. There are currently 26 repositories in the organization: one for the documentation, one for a utility package, 21 active packages and three that are currently unsupported, maintained primarily by me and Guillaume Piolat.

The Derelict packages primarily provide [dynamic bindings](http://derelictorg.github.io/bindings/), though some can be configured as static bindings at compile time. Dynamic bindings require the C libraries to which they bind to be dynamically loaded at run time. The mechanism for this is provided by the [DerelictUtil](https://github.com/DerelictOrg/DerelictUtil) package. Loading a library is as simple as a function call, e.g. `DerelictSDL2.load();`.

Static bindings have a link-time dependency, requiring either statically or dynamically linking with the bound C library when building an executable. In that case, the dependency on DerelictUtil goes away (some packages may still use a few DerelictUtil declarations, requiring one of its modules to be imported, but it need not be linked into the program). On Windows, this introduces [potential issues](http://derelictorg.github.io/building/windows/) with object file formats, but these days they are quite easy to solve.

It's hard to believe now, but Derelict has been around continuously, in one form or another, since March of 2004. I was first drawn to D because it fit almost perfectly between the two languages I had the most experience with back in 2003, C and Java. It addressed some of the frustrations I had with each while combining things I loved from both. But early on I ran into my first frustration with D.

At the time, interfacing with C libraries on Windows was a bit annoying. D has excellent support for and compatibility with C libraries in the language, but the object file format issues I alluded to above were frustrating. DMD on Windows could only output object files in the [OMF](https://en.wikipedia.org/wiki/Relocatable_Object_Module_Format) format and could only use the [OPTLINK](http://www.digitalmars.com/ctg/optlink.html) linker, an ancient 32-bit linker that only understands OMF. This is because DMD was implemented on top of backend and tool chain used by the [DMC](http://www.digitalmars.com/download/freecompiler.html), the Digital Mars C and C++ compiler. Meanwhile, the rest of the Microsoft ecosystem was (and is) using the [COFF](https://en.wikipedia.org/wiki/COFF) format. In practice, a static binding to a C library required either using tools to convert the object files or libraries from OMF to COFF, or compiling the C library with DMC. You don't tend to find support for DMC in most build scripts.

When I found that the bindings for the libraries I wanted to use (SDL and OpenGL) were static, I resolved to create my own. I'm a big fan of dynamic loading, so it was a no-brainer to create dynamic bindings. When you load a DLL via the `LoadLibrary`/`GetProcAddress` API, the object file format is irrelevant. From that point on, I never had to worry about the COFF/OMF problem again. Even though the problem didn't exist outside of Windows, I made them cross platform anyway to keep a consistent interface.

In those days, DMD 1.0.0 wasn't yet a thing, but a new web site, dsource.org, had just been launched to host open source D projects (much of the site [is still online](http://dsource.org/projects/derelict) in archive mode thanks to Vladimir Panteleev). All of the projects there used Subversion, so I decided to learn my way around it and take a stab at maintaining an open source project by making my new bindings available. Part of my motivation for picking "Derelict" as the title is because I fully expected no one else would be interested and, whether they were or not, I would eventually abandon it anyway.

As it turned out, people really were interested. Contributions started coming in almost immediately, along with questions and suggestions on the DSource forums. I added new bindings, set up criteria on new binding submissions (they must be gamedev-related and cross-platform), and added documentation on how to create "Derelictified" bindings. Tomasz Stachowiak (now a [Frostbite](https://en.wikipedia.org/wiki/Frostbite_(game_engine)) game engine developer) came along and started making contributions, including a templated loader in DerelictUtil that replaced the one I had hacked together and became the basis for Derelict2.

Eventually, with the dawning of the D2 era, D development moved away from DSource to GitHub. So did Derelict, in the guise of [Derelict 3](https://github.com/mdparker/Derelict3). I had made use of every D build tool that came along before then, but finally settled on a custom build script (written in D) for this iteration, since the build tools all died. When [DUB](https://code.dlang.org/getting_started) came along and looked like it was here to stay, I fully committed to it. I took the opportunity to finally split up the monolithic repository, gave every package its own repo, and created DerelictOrg as their new home. Aside from the appalling lack of documentation (a state which [is rapidly changing](http://derelictorg.github.io/), but is still a WIP), things have been fairly stable.

If I were still counting from Derelict 3, I think we might be at Derelict 6 by now, but that's not how it rolls anymore. Since the move to DerelictOrg, I've twice made iterative improvements to DerelictUtil that broke binary compatibility with previous releases. The first time around, I didn't properly manage the roll out. Anyone building the Derelict libraries manually, i.e. when they weren't using DUB to manage their application project, could run into issues where one package used the new version and another used the older. It seems like it ought to have been a mess, but I heard very little about it. Still, in the most recent overhaul, I took steps to keep the new stuff distinctly separate from the old stuff and rolled it all out at once (which is why most of [the latest releases](http://derelictorg.github.io/packages/latest-versions/) as I write have a -beta suffix).

As D has evolved over the years, so has Derelict. Now that DMD supports COFF on Windows, some of the packages can now be configured at compile time as a static binding. Long ago, DerelictUtil gained the ability to selectively ignore missing symbols (curiously missing from the latest docs, but described in the old [DerelictUtil Wiki](https://github.com/DerelictOrg/DerelictUtil/wiki/DerelictUtil-for-Users#selective-symbol-loading)) and more recently gained a feature that enables a package implementation to support multiple versions of a C library via a configurable call to the loader ([SharedLibVersion](http://derelictorg.github.io/loading/loader/#sharedlibversion)), which only a handful of packages support and few more likely will (due to API compatibility issues with type sizes or `enum` values, not every package can). The latest version of DerelictGL3 is [massively configurable](http://derelictorg.github.io/packages/gl3/) at compile time. For a little while, I even relaxed my criteria for allowing new packages under the DerelictOrg umbrella, but now after I ended up being wholly responsible for them that's something I'm not inclined to continue. With the DUB registry, it's not really necessary.

There are a number of C library bindings using DerelictUtil out in the wild. You can find them, as well as all of the DerelictOrg packages, at [the DUB package registry](https://code.dlang.org/). Some of the third-party bindings have a name like "derelict-extras-foo", but others use "derelict-foo" like those in DerelictOrg. You can also find a collection of static bindings in [the Deimos organization](https://github.com/D-Programming-Deimos), and third-party static bindings in the DUB registry that have adopted the Deimos approach of providing C headers along side the D modules.

Anyone who needs help with any of the Derelict packages can often find it in the #D irc channel at freenode.net. I drop by infrequently, but I monitor the D forums every day. Asking for Derelict help in the [Learn forum](http://forum.dlang.org/group/learn) is not off-topic.

The Derelict bindings have gone well beyond targeting game developers. Though they're often used in games (like [Voxelman](http://dlang.org/blog/2016/12/30/project-highlight-voxelman/) and the first D game on Steam, [Mayhem Intergalactic](http://store.steampowered.com/app/18600/Mayhem_Intergalactic/)), they are also used elsewhere (like [DLangUI](http://dlang.org/blog/2016/10/07/project-highlight-dlangui/)). If you're using any of the Derelict bindings in your own projects, I'd love to hear about it. Particularly since I'm always looking for projects I've never heard about to highlight here on the blog.
